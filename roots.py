# -*- coding: utf-8 -*-
"""Roots.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15No5N5P7YHiTdEzefuXQD-nyK8BuOXxv
"""

#All programs done to comapre root value by the three methods
#First root of every equation has been found and compared.
#some function contain multiple roots, which can be found by changing the bound values(a and b)
#suitable a and b values will be mentioned alongside.

#cos(x)
#finding roots
import numpy as np
import matplotlib.pyplot as plt
#plotting the graph
x=np.arange(0,2*np.pi,0.01)
def f(x):
    return np.cos(x)
plt.plot(x,f(x),'-',color='red')
plt.show()
def fdash(x):
    h=0.001
    return (f(x+h)-f(x-h))/(2*h)

#Bisection method
a=1
b=6
#finding first root lying around pi/2,other roots are 3pi/2,5pi/2...
#range of a and b must have atleast one root !!
#if many roots are present in this range,output will be the first root encountered.
while(np.abs(a-b)>10**-10):
    z=(a+b)/2
    
    if (np.abs(f(a))>np.abs(f(b))):
        a=z
    else :
        b=z
    
print("value from bisection method",z)
print("Value of pi/2 where root lies",np.pi/2)

#newtons method
a=2.5
#value of 'a' can be between 0.5-2.5 to get 1st root
#if we increase value of a to somewhere between 3.6 and 5.8, we get 2nd root ie 3pi/2.
#the root that is found depends solely on value of "a"
#And the range in wich 'a' has to be in order to get the desired root is very sensitive.
while(np.abs(f(a))>10**(-10)):
    b=a-f(a)/fdash(a)
    a=b
print("From newton's method",a)

#newtons method is not good enough since value of 'a' has to be wisely chosen!!


#secant method
a=1
b=3
#a and b value can be such that the root lies within its range.
#Important to note , Within the range of a and b, just one root must lie!!
while np.abs(f(a))>10**(-10):
    c=a-f(a)*(b-a)/(f(b)-f(a))
    a=c
print ("By secant method = ",a)

#x^3-30x^2+2552
#finding roots
import numpy as np
import matplotlib.pyplot as plt
#plotting the graph
x=np.arange(0,30,0.01)
def f(x):
    return x**3-30*(x**2)+2552
plt.plot(x,f(x),'-',color='red')
plt.show()
def fdash(x):
    h=0.001
    return (f(x+h)-f(x-h))/(2*h)
#Bisection method 
a=0
b=30 #in this range both the roots lie but here we will get just one root value , that is the first root lying between 9 -11 
while(np.abs(a-b)>10**-10):
    z=(a+b)/2
    
    if (f(z)>0):
        a=z
        
    else :
        b=z
    
print(" bisection method x1",z)
a=22
b=28 #2nd root
while(np.abs(a-b)>10**-10):
    z=(a+b)/2
    
    if (np.abs(f(a))>np.abs(f(b))):
        a=z
        
    else :
        b=z
    
print(" bisection method x2",z)

#newtons method
a=8.223 #this value will give first root, if the value of a is somewhere above 20 then it would give next root

while(np.abs(f(a))>10**(-10)):
    b=a-f(a)/fdash(a)
    a=b
print("From newton's method x1",a)
a=20.223 

while(np.abs(f(a))>10**(-10)):
    b=a-f(a)/fdash(a)
    a=b
print("From newton's method x2",a)

#secant method
a=7
b=20 
# 1st root shown that lies between 9-11)
while np.abs(f(a))>10**(-10):
    c=a-f(a)*(b-a)/(f(b)-f(a))
    a=c
print ("By secant method x1 = ",a)
a=22
b=30 
# 1st root shown that lies between 9-11)
while np.abs(f(a))>10**(-10):
    c=a-f(a)*(b-a)/(f(b)-f(a))
    a=c
print ("By secant method x2= ",a)

#arctan(x)
#finding roots
import numpy as np
import matplotlib.pyplot as plt
#plotting the graph
x=np.arange(-10,10,0.0001)
def f(x):
    return np.arctan(x)
plt.plot(x,f(x),'-',color='red')
plt.show()
def fdash(x):
    h=0.001
    return (f(x+h)-f(x-h))/(2*h)
#Bisection method
a=-10
b=10
while(np.abs(a-b)>10**-10):
    z=(a+b)/2
    
    if (f(z)>0):
        b=z
        
    else :
        a=z
    
print("value from bisection method",z)

#newtons method
a=np.pi/3 #Note that pi/2 or above gives divide by zero error,so choose 'a' wisely.
#negative value of 'a' will just give the negative value closest to first root.

while(np.abs(f(a))>10**(-10)):
    b=a-f(a)/fdash(a)
    a=b
print("From newton's method",a)

#secant method
a=-0.9
b=0.9
while np.abs(f(a))>10**(-10):
    c=a-f(a)*(b-a)/(f(b)-f(a))
    a=c
print ("By secant method = ",a)

#x^2-4xsinx+(2sinx)^2
#finding roots
import numpy as np
import matplotlib.pyplot as plt
#plotting the graph
x=np.arange(-2.5,2.5,0.001)
def f(x):
    return x**2-4*x*np.sin(x)+(2*np.sin(x))**2
plt.plot(x,f(x),'-',color='red')
plt.show()
def fdash(x):
    h=0.001
    return (f(x+h)-f(x-h))/(2*h)

#Bisection method
a=-3
b=-1
#gives root between 1-3
while(np.abs(a-b)>10**-10):
    z=(a+b)/2
    
    if (np.abs(f(a))>np.abs(f(b))):
        a=z
    else :
        b=z
    
print("bisection method x1",z)
a=-1
b=1
#gives root between 1-3
while(np.abs(a-b)>10**-10):
    z=(a+b)/2
    
    if (np.abs(f(a))>np.abs(f(b))):
        a=z
    else :
        b=z
    
print("bisection method x2",z)
a=1
b=3
#gives root between 1-3
while(np.abs(a-b)>10**-10):
    z=(a+b)/2
    
    if (np.abs(f(a))>np.abs(f(b))):
        a=z
    else :
        b=z
    
print("bisection method x3",z)
#newtons method

a= -2
while(np.abs(f(a))>10**(-10)):
    b=a-f(a)/fdash(a)
    a=b
print("From newton's method x1",a)
a= 0.4
while(np.abs(f(a))>10**(-10)):
    b=a-f(a)/fdash(a)
    a=b
print("From newton's method x2",a)
a= 2
while(np.abs(f(a))>10**(-10)):
    b=a-f(a)/fdash(a)
    a=b
print("From newton's method x3",a)
#secant method
a=-2
b=-1.5
while np.abs(f(a))>10**(-10):
    c=a-f(a)*(b-a)/(f(b)-f(a))
    a=c
print ("By secant method x1= ",a)
a=-.1
b=.5
while np.abs(f(a))>10**(-10):
    c=a-f(a)*(b-a)/(f(b)-f(a))
    a=c
print ("By secant method x2= ",a)
a=1
b=2
while np.abs(f(a))>10**(-10):
    c=a-f(a)*(b-a)/(f(b)-f(a))
    a=c
print ("By secant method x3= ",a)

